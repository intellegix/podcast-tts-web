<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podcast TTS Generator</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="{{ url_for('static', filename='pipeline.js') }}" defer></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Podcast TTS Generator</h1>
            <p class="subtitle">Convert your podcast scripts to audio using OpenAI TTS</p>
        </header>

        <main>
            <form id="tts-form">
                <div class="form-section">
                    <label for="text">Paste your script:</label>
                    <textarea
                        id="text"
                        name="text"
                        placeholder="Paste your podcast script here... Supports plain text and markdown."
                        rows="12"
                    ></textarea>
                </div>

                <div class="divider">
                    <span>OR</span>
                </div>

                <div class="form-section">
                    <label for="file">Upload a text file:</label>
                    <div class="file-upload">
                        <input type="file" id="file" name="file" accept=".txt,.md,.text">
                        <span class="file-label" id="file-label">Choose file (.txt, .md)</span>
                    </div>
                </div>

                <div class="options-row">
                    <div class="form-section">
                        <label for="voice">Voice:</label>
                        <select id="voice" name="voice">
                            {% for voice in voices %}
                            <option value="{{ voice }}" {% if voice == 'nova' %}selected{% endif %}>
                                {{ voice.capitalize() }}
                            </option>
                            {% endfor %}
                        </select>
                        <small class="voice-hint">
                            <strong>Nova:</strong> Warm, natural |
                            <strong>Alloy:</strong> Neutral |
                            <strong>Echo:</strong> Deeper |
                            <strong>Fable:</strong> British |
                            <strong>Onyx:</strong> Deep male |
                            <strong>Shimmer:</strong> Expressive
                        </small>
                    </div>

                    <div class="form-section">
                        <label for="model">Quality:</label>
                        <select id="model" name="model">
                            {% for model in models %}
                            <option value="{{ model }}" {% if model == 'tts-1-hd' %}selected{% endif %}>
                                {{ 'HD (Higher quality)' if model == 'tts-1-hd' else 'Standard (Faster)' }}
                            </option>
                            {% endfor %}
                        </select>
                    </div>
                </div>

                <div class="form-section checkbox-section">
                    <label class="checkbox-label">
                        <input type="checkbox" id="multi_voice" name="multi_voice" value="true">
                        <span class="checkbox-text">Multi-voice mode</span>
                    </label>
                    <small class="multi-voice-hint">
                        Auto-detect speakers (ALEX:, SARAH:) and assign different voices based on gender.
                        <br><strong>Male:</strong> Echo | <strong>Female:</strong> Shimmer | <strong>Unknown:</strong> Alloy
                    </small>
                </div>

                <div class="form-section checkbox-section auto-expand-section">
                    <label class="checkbox-label">
                        <input type="checkbox" id="auto_expand" name="auto_expand" value="true" checked>
                        <span class="checkbox-text">Auto-expand incomplete scripts</span>
                    </label>
                    <small class="multi-voice-hint">
                        Automatically detect and expand incomplete episodes using GPT-4o.
                        <br>Detects outlines, bullet points, and instructions like "(describe...)" and converts them to full dialogue.
                    </small>
                </div>

                <div class="form-section checkbox-section ai-enhance-section">
                    <label class="checkbox-label">
                        <input type="checkbox" id="ai_enhance" name="ai_enhance" value="true" checked>
                        <span class="checkbox-text">AI Enhancement Pipeline</span>
                    </label>
                    <small class="multi-voice-hint">
                        Enterprise-grade multi-AI processing using parallel agents:
                        <br><strong>Perplexity:</strong> Research facts, statistics, and current data
                        <br><strong>Claude:</strong> Polish dialogue for natural flow, pacing, and TTS optimization
                    </small>
                </div>

                <button type="submit" id="generate-btn">
                    <span class="btn-text">Generate Audio</span>
                    <span class="btn-icon">&#9658;</span>
                </button>
            </form>

            <div id="progress-section" class="hidden">
                <!-- Pipeline Canvas Background -->
                <div class="pipeline-container">
                    <canvas id="pipeline-canvas"></canvas>

                    <!-- Glassmorphism Overlay -->
                    <div class="pipeline-overlay">
                        <!-- Stage Indicator Bar -->
                        <div class="stage-indicators">
                            <div class="stage" data-stage="analyze">
                                <div class="stage-icon">üìÑ</div>
                                <div class="stage-label">Analyze</div>
                            </div>
                            <div class="stage-connector"></div>
                            <div class="stage" data-stage="research">
                                <div class="stage-icon">üîç</div>
                                <div class="stage-label">Research</div>
                            </div>
                            <div class="stage-connector"></div>
                            <div class="stage" data-stage="enhance">
                                <div class="stage-icon">üß†</div>
                                <div class="stage-label">Enhance</div>
                            </div>
                            <div class="stage-connector"></div>
                            <div class="stage" data-stage="generate">
                                <div class="stage-icon">üéôÔ∏è</div>
                                <div class="stage-label">Generate</div>
                            </div>
                            <div class="stage-connector"></div>
                            <div class="stage" data-stage="combine">
                                <div class="stage-icon">‚ú®</div>
                                <div class="stage-label">Complete</div>
                            </div>
                        </div>

                        <!-- Current Status -->
                        <div class="progress-content">
                            <h2 id="stage-title">Initializing...</h2>
                            <p id="progress-message">Starting pipeline...</p>

                            <!-- Chunk Progress (for TTS stage) -->
                            <div id="chunk-progress">
                                <div class="chunk-bar">
                                    <div class="chunk-fill" id="chunk-fill"></div>
                                </div>
                                <span id="chunk-count">0 / 0 chunks</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- AI Workbench - Real-time Insights -->
                <div class="ai-workbench">
                    <!-- Workbench Header with Tabs -->
                    <div class="workbench-header">
                        <h3>AI Workbench</h3>
                        <div class="workbench-tabs">
                            <button class="tab-btn active" data-tab="activity">Activity</button>
                            <button class="tab-btn" data-tab="sources">Sources <span id="source-count" class="tab-badge hidden">0</span></button>
                            <button class="tab-btn" data-tab="changes">Changes <span id="change-count" class="tab-badge hidden">0</span></button>
                        </div>
                    </div>

                    <!-- Activity Feed Tab -->
                    <div class="workbench-panel active" id="activity-panel">
                        <div class="activity-feed" id="activity-feed">
                            <div class="activity-item thinking">
                                <span class="activity-icon">üîÑ</span>
                                <span class="activity-text">Initializing pipeline...</span>
                                <span class="activity-time">now</span>
                            </div>
                        </div>
                    </div>

                    <!-- Sources Tab (Perplexity Citations) -->
                    <div class="workbench-panel" id="sources-panel">
                        <div class="sources-list" id="sources-list">
                            <div class="empty-state">
                                <span class="empty-icon">üîç</span>
                                <p>Sources will appear here when Perplexity researches your content</p>
                            </div>
                        </div>
                    </div>

                    <!-- Changes Tab (Claude Edits) -->
                    <div class="workbench-panel" id="changes-panel">
                        <div class="changes-list" id="changes-list">
                            <div class="empty-state">
                                <span class="empty-icon">üß†</span>
                                <p>Claude's enhancements will appear here</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Stage Preview Panel (for interactive pipeline) -->
                <div id="stage-preview-panel" class="hidden">
                    <div class="preview-header">
                        <h3 id="preview-stage-name">Stage Output</h3>
                        <span class="preview-badge">Review Required</span>
                    </div>

                    <div class="preview-content-wrapper">
                        <pre id="preview-content" class="preview-text"></pre>
                    </div>

                    <!-- Citations (shown during research stage) -->
                    <div id="preview-citations" class="preview-citations hidden">
                        <h4>Research Sources</h4>
                        <div id="preview-citations-list"></div>
                    </div>

                    <!-- Changes (shown during enhance stage) -->
                    <div id="preview-changes" class="preview-changes hidden">
                        <h4>Changes Made</h4>
                        <div id="preview-changes-list"></div>
                    </div>

                    <!-- Quick Suggestion Buttons -->
                    <div class="quick-suggestions">
                        <span class="quick-label">Quick suggestions:</span>
                        <button type="button" class="quick-btn" data-suggestion="Focus on statistics and data">More statistics</button>
                        <button type="button" class="quick-btn" data-suggestion="Make it funnier and more engaging">Make it funnier</button>
                        <button type="button" class="quick-btn" data-suggestion="Add more real-world examples">More examples</button>
                        <button type="button" class="quick-btn" data-suggestion="Simplify the language">Simplify</button>
                        <button type="button" class="quick-btn" data-suggestion="Make it more conversational">More casual</button>
                    </div>

                    <!-- Custom Input -->
                    <div class="suggestion-input-wrapper">
                        <textarea id="suggestion-input" placeholder="Optional: Enter your own guidance for the next stage..." rows="2"></textarea>
                    </div>

                    <!-- Continue Button -->
                    <div class="preview-actions">
                        <button type="button" id="continue-btn" class="continue-btn">
                            <span>Continue to Next Stage</span>
                            <span class="btn-arrow">&#8594;</span>
                        </button>
                        <button type="button" id="skip-reviews-btn" class="skip-btn">
                            Skip All Reviews
                        </button>
                    </div>
                </div>
            </div>

            <div id="result-section" class="hidden">
                <div class="success-icon">&#10003;</div>
                <h2>Audio Generated!</h2>
                <p id="result-filename" class="result-filename"></p>
                <p id="result-size">Size: 0 MB</p>
                <div class="download-buttons">
                    <a id="download-link" class="download-btn" href="#">
                        Download MP3
                    </a>
                    <a id="transcript-link" class="download-btn transcript-btn hidden" href="#">
                        üìÑ Download Transcript
                    </a>
                </div>
            </div>

            <div id="error-section" class="hidden">
                <div class="error-icon">&#10007;</div>
                <h2>Error</h2>
                <p id="error-message">Something went wrong.</p>
                <button onclick="resetForm()" class="retry-btn">Try Again</button>
            </div>
        </main>

        <footer>
            <p>Powered by OpenAI TTS API</p>
        </footer>
    </div>

    <script>
        // DOM Elements
        const form = document.getElementById('tts-form');
        const fileInput = document.getElementById('file');
        const fileLabel = document.getElementById('file-label');
        const generateBtn = document.getElementById('generate-btn');
        const progressSection = document.getElementById('progress-section');
        const resultSection = document.getElementById('result-section');
        const errorSection = document.getElementById('error-section');
        const progressMessage = document.getElementById('progress-message');
        const chunkFill = document.getElementById('chunk-fill');
        const chunkCount = document.getElementById('chunk-count');
        const downloadLink = document.getElementById('download-link');
        const resultSize = document.getElementById('result-size');
        const errorMessage = document.getElementById('error-message');
        const resultFilename = document.getElementById('result-filename');
        const transcriptLink = document.getElementById('transcript-link');

        // Workbench elements
        const activityFeed = document.getElementById('activity-feed');
        const sourcesList = document.getElementById('sources-list');
        const changesList = document.getElementById('changes-list');
        const sourceCountBadge = document.getElementById('source-count');
        const changeCountBadge = document.getElementById('change-count');

        // Track sources and changes
        let allSources = [];
        let allChanges = [];
        let startTime = null;

        // Workbench tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update active tab
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // Show corresponding panel
                const tabName = btn.dataset.tab;
                document.querySelectorAll('.workbench-panel').forEach(p => p.classList.remove('active'));
                document.getElementById(tabName + '-panel').classList.add('active');
            });
        });

        // File input label update
        fileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                fileLabel.textContent = this.files[0].name;
                fileLabel.classList.add('has-file');
            } else {
                fileLabel.textContent = 'Choose file (.txt, .md)';
                fileLabel.classList.remove('has-file');
            }
        });

        // Form submission
        form.addEventListener('submit', async function(e) {
            e.preventDefault();

            const text = document.getElementById('text').value;
            const file = fileInput.files[0];

            if (!text.trim() && !file) {
                alert('Please paste a script or upload a file.');
                return;
            }

            // Reset workbench state
            resetWorkbench();
            startTime = Date.now();

            // Show progress and start pipeline animation
            form.classList.add('hidden');
            progressSection.classList.remove('hidden');
            resultSection.classList.add('hidden');
            errorSection.classList.add('hidden');

            // Initialize and start pipeline visualization
            if (typeof initPipeline === 'function') {
                initPipeline();
                startPipeline('analyze');
            }

            addActivity('üöÄ', 'Pipeline started', 'thinking');

            const formData = new FormData(form);

            try {
                const response = await fetch('/generate', {
                    method: 'POST',
                    body: formData
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const text = decoder.decode(value);
                    const lines = text.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                handleProgress(data);
                            } catch (e) {
                                console.error('Parse error:', e);
                            }
                        }
                    }
                }
            } catch (error) {
                showError('Network error: ' + error.message);
            }
        });

        function handleProgress(data) {
            if (data.status === 'processing') {
                progressMessage.textContent = data.message;

                // Update pipeline stage if provided
                if (data.stage && typeof updatePipelineStage === 'function') {
                    let progress = 0;
                    if (data.total && data.current) {
                        progress = data.current / data.total;
                    }
                    updatePipelineStage(data.stage, progress);
                }

                // Add activity for stage changes
                const stageIcons = {
                    'analyze': 'üìÑ',
                    'research': 'üîç',
                    'enhance': 'üß†',
                    'generate': 'üéôÔ∏è',
                    'combine': '‚ú®'
                };
                if (data.stage && stageIcons[data.stage]) {
                    addActivity(stageIcons[data.stage], data.message, data.stage);
                }

                // Handle scaling info from multiplier logic
                if (data.scaling) {
                    const s = data.scaling;
                    addActivity('‚ö°',
                        `Auto-scaled to ${s.target_agents} agents for ${s.estimated_minutes.toFixed(0)} min content (${s.word_count.toLocaleString()} words)`,
                        'analyze'
                    );
                    if (s.use_batching) {
                        addActivity('üì¶',
                            `Batch mode enabled: processing ${s.batch_size} episodes per batch`,
                            'analyze'
                        );
                    }
                }

                // Handle citations from Perplexity
                if (data.citations && data.citations.length > 0) {
                    updateSources(data.citations, data.research_findings);
                }

                // Handle changes from Claude
                if (data.changes) {
                    console.log('Received changes:', data.changes);
                    if (data.changes.length > 0) {
                        updateChanges(data.changes);
                    }
                }

                // Update chunk progress for generate stage
                if (data.total && data.current) {
                    const percent = (data.current / data.total) * 100;
                    chunkFill.style.width = percent + '%';
                    chunkCount.textContent = `${data.current} / ${data.total} chunks`;
                }
            } else if (data.status === 'complete') {
                // Stop pipeline animation
                if (typeof stopPipeline === 'function') {
                    stopPipeline();
                }

                addActivity('‚úÖ', 'Audio generated successfully!', 'complete');

                progressSection.classList.add('hidden');
                resultSection.classList.remove('hidden');
                resultSize.textContent = `Size: ${data.size_mb} MB`;

                // Use smart filename if provided
                if (data.filename && resultFilename) {
                    resultFilename.textContent = data.filename;
                }

                downloadLink.href = `/download/${data.download_id}`;
                if (data.filename) {
                    downloadLink.download = data.filename;
                }
                downloadLink.onclick = function() {
                    // Cleanup after 5 minutes to allow transcript download
                    setTimeout(() => {
                        fetch(`/cleanup/${data.download_id}`, { method: 'POST' });
                    }, 300000);
                };

                // Show transcript download link
                if (data.transcript_id) {
                    transcriptLink.href = `/download-transcript/${data.transcript_id}`;
                    transcriptLink.classList.remove('hidden');
                    addActivity('üìÑ', 'Transcript available for download', 'complete');
                }
            } else if (data.status === 'error') {
                showError(data.message);
            }
        }

        function addActivity(icon, text, type = 'info') {
            const elapsed = startTime ? Math.round((Date.now() - startTime) / 1000) : 0;
            const timeStr = elapsed < 60 ? `${elapsed}s` : `${Math.floor(elapsed/60)}m ${elapsed%60}s`;

            const item = document.createElement('div');
            item.className = `activity-item ${type}`;
            item.innerHTML = `
                <span class="activity-icon">${icon}</span>
                <span class="activity-text">${text}</span>
                <span class="activity-time">${timeStr}</span>
            `;

            // Add to top of feed
            activityFeed.insertBefore(item, activityFeed.firstChild);

            // Limit feed length
            while (activityFeed.children.length > 50) {
                activityFeed.removeChild(activityFeed.lastChild);
            }
        }

        function updateSources(citations, findings) {
            allSources = [...new Set([...allSources, ...citations])];

            // Update badge
            sourceCountBadge.textContent = allSources.length;
            sourceCountBadge.classList.remove('hidden');

            // Update sources panel
            let html = '<div class="sources-header"><h4>Research Sources</h4><span class="source-total">' + allSources.length + ' sources found</span></div>';

            // Add findings if available
            if (findings && findings.length > 0) {
                html += '<div class="findings-section">';
                findings.forEach(f => {
                    html += `
                        <div class="finding-item">
                            <div class="finding-header">
                                <span class="finding-episode">Episode ${f.episode}</span>
                                <span class="finding-sources">${f.source_count} sources</span>
                            </div>
                            <div class="finding-topic">${escapeHtml(f.topic)}</div>
                            <div class="finding-preview">${escapeHtml(f.findings_preview)}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            // Add citation URLs
            html += '<div class="citations-section"><h4>Citation URLs</h4>';
            allSources.forEach((url, i) => {
                const domain = extractDomain(url);
                html += `
                    <a href="${escapeHtml(url)}" target="_blank" class="citation-link">
                        <span class="citation-number">${i + 1}</span>
                        <span class="citation-domain">${domain}</span>
                        <span class="citation-icon">‚Üó</span>
                    </a>
                `;
            });
            html += '</div>';

            sourcesList.innerHTML = html;

            // Add activity
            addActivity('üìö', `Found ${allSources.length} research sources`, 'research');
        }

        function updateChanges(changes) {
            allChanges = changes;

            // Update badge
            const totalAdded = changes.reduce((sum, c) => sum + c.words_added, 0);
            changeCountBadge.textContent = '+' + totalAdded;
            changeCountBadge.classList.remove('hidden');

            // Update changes panel
            let html = '<div class="changes-header"><h4>Claude Enhancements</h4></div>';

            changes.forEach(change => {
                const sign = change.length_change >= 0 ? '+' : '';
                html += `
                    <div class="change-item">
                        <div class="change-header">
                            <span class="change-episode">Episode ${change.episode}</span>
                            <span class="change-stats">
                                <span class="stat-added">+${change.words_added} words</span>
                                <span class="stat-removed">-${change.words_removed} words</span>
                                <span class="stat-length">${sign}${change.length_change} chars</span>
                            </span>
                        </div>
                        <div class="change-samples">
                            <div class="samples-label">Sample additions:</div>
                            ${change.sample_additions.map(s => `<div class="sample-line">"${escapeHtml(s)}"</div>`).join('')}
                        </div>
                    </div>
                `;
            });

            changesList.innerHTML = html;

            // Add activity
            addActivity('‚úèÔ∏è', `Claude added ${totalAdded} words across ${changes.length} episodes`, 'enhance');
        }

        function extractDomain(url) {
            try {
                const u = new URL(url);
                return u.hostname.replace('www.', '');
            } catch {
                return url.substring(0, 30);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function resetWorkbench() {
            allSources = [];
            allChanges = [];
            activityFeed.innerHTML = '';
            sourcesList.innerHTML = '<div class="empty-state"><span class="empty-icon">üîç</span><p>Sources will appear here when Perplexity researches your content</p></div>';
            changesList.innerHTML = '<div class="empty-state"><span class="empty-icon">üß†</span><p>Claude\'s enhancements will appear here</p></div>';
            sourceCountBadge.classList.add('hidden');
            changeCountBadge.classList.add('hidden');
            chunkFill.style.width = '0%';
            chunkCount.textContent = '0 / 0 chunks';
            transcriptLink.classList.add('hidden');
        }

        function showError(message) {
            // Stop pipeline animation
            if (typeof stopPipeline === 'function') {
                stopPipeline();
            }

            addActivity('‚ùå', message, 'error');

            progressSection.classList.add('hidden');
            resultSection.classList.add('hidden');
            errorSection.classList.remove('hidden');
            errorMessage.textContent = message;
        }

        function resetForm() {
            form.classList.remove('hidden');
            progressSection.classList.add('hidden');
            resultSection.classList.add('hidden');
            errorSection.classList.add('hidden');
            chunkFill.style.width = '0%';
            chunkCount.textContent = '0 / 0 chunks';
            generateBtn.disabled = false;
            // Reset interactive pipeline state
            if (interactivePipeline) {
                interactivePipeline.reset();
            }
        }

        // ========================================
        // Interactive Pipeline Class
        // ========================================
        class InteractivePipeline {
            constructor() {
                this.jobId = null;
                this.pollInterval = null;
                this.skipReviews = false;
                this.isActive = false;

                // DOM elements
                this.previewPanel = document.getElementById('stage-preview-panel');
                this.previewStageName = document.getElementById('preview-stage-name');
                this.previewContent = document.getElementById('preview-content');
                this.previewCitations = document.getElementById('preview-citations');
                this.previewCitationsList = document.getElementById('preview-citations-list');
                this.previewChanges = document.getElementById('preview-changes');
                this.previewChangesList = document.getElementById('preview-changes-list');
                this.suggestionInput = document.getElementById('suggestion-input');
                this.continueBtn = document.getElementById('continue-btn');
                this.skipReviewsBtn = document.getElementById('skip-reviews-btn');

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Quick suggestion buttons
                document.querySelectorAll('.quick-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const suggestion = e.target.dataset.suggestion;
                        this.suggestionInput.value = suggestion;
                        // Visual feedback
                        document.querySelectorAll('.quick-btn').forEach(b => b.classList.remove('selected'));
                        e.target.classList.add('selected');
                    });
                });

                // Continue button
                this.continueBtn.addEventListener('click', () => {
                    this.continueWithSuggestion(this.suggestionInput.value);
                });

                // Skip all reviews button
                this.skipReviewsBtn.addEventListener('click', () => {
                    this.skipReviews = true;
                    this.continueWithSuggestion('');
                });
            }

            async startJob(formData) {
                this.isActive = true;
                this.skipReviews = false;

                try {
                    const response = await fetch('/api/job', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to create job');
                    }

                    const data = await response.json();
                    this.jobId = data.job_id;

                    addActivity('üöÄ', 'Interactive pipeline started', 'thinking');
                    this.startPolling();

                } catch (error) {
                    showError('Failed to start job: ' + error.message);
                }
            }

            startPolling() {
                this.stopPolling();
                this.pollInterval = setInterval(() => this.checkStatus(), 1500);
            }

            stopPolling() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }
            }

            async checkStatus() {
                if (!this.jobId || !this.isActive) return;

                try {
                    const response = await fetch(`/api/job/${this.jobId}/status`);
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to get status');
                    }

                    const data = await response.json();
                    this.handleStatusUpdate(data);

                } catch (error) {
                    console.error('Status check failed:', error);
                    // Don't show error for transient failures
                }
            }

            handleStatusUpdate(data) {
                // Update pipeline stage visualization
                if (data.current_stage && typeof updatePipelineStage === 'function') {
                    updatePipelineStage(data.current_stage, 0.5);
                }

                // Update stage title
                if (data.stage_name) {
                    document.getElementById('stage-title').textContent = data.stage_name;
                }

                switch (data.status) {
                    case 'running':
                        progressMessage.textContent = `Processing ${data.stage_name || data.current_stage}...`;
                        this.hidePreviewPanel();
                        break;

                    case 'paused_for_review':
                        this.stopPolling();
                        if (this.skipReviews) {
                            // Auto-continue without showing preview
                            this.continueWithSuggestion('');
                        } else {
                            this.showStagePreview(data);
                        }
                        break;

                    case 'complete':
                        this.stopPolling();
                        this.showComplete(data);
                        break;

                    case 'error':
                        this.stopPolling();
                        showError(data.error_message || 'Pipeline error');
                        break;
                }
            }

            showStagePreview(data) {
                const preview = data.stage_preview;
                if (!preview) return;

                // Update stage name
                this.previewStageName.textContent = preview.stage_name + ' Complete';

                // Update preview content
                this.previewContent.textContent = preview.preview || 'No preview available';

                // Show citations if available (research stage)
                if (preview.citations && preview.citations.length > 0) {
                    this.previewCitations.classList.remove('hidden');
                    this.previewCitationsList.innerHTML = preview.citations.map((url, i) => {
                        const domain = this.extractDomain(url);
                        return `<a href="${this.escapeHtml(url)}" target="_blank" class="citation-link">
                            <span class="citation-number">${i + 1}</span>
                            <span class="citation-domain">${domain}</span>
                        </a>`;
                    }).join('');

                    // Also update the sources panel
                    updateSources(preview.citations, null);
                } else {
                    this.previewCitations.classList.add('hidden');
                }

                // Show changes if available (enhance stage)
                if (preview.changes && preview.changes.length > 0) {
                    this.previewChanges.classList.remove('hidden');
                    this.previewChangesList.innerHTML = preview.changes.map(change => {
                        return `<div class="change-item-mini">
                            <span class="change-ep">Ep ${change.episode}</span>
                            <span class="change-stat">+${change.words_added} words</span>
                        </div>`;
                    }).join('');

                    // Also update the changes panel
                    updateChanges(preview.changes);
                } else {
                    this.previewChanges.classList.add('hidden');
                }

                // Clear previous suggestion
                this.suggestionInput.value = '';
                document.querySelectorAll('.quick-btn').forEach(b => b.classList.remove('selected'));

                // Show the preview panel
                this.previewPanel.classList.remove('hidden');

                // Add activity
                const stageIcons = {
                    'analyze': 'üìÑ',
                    'research': 'üîç',
                    'enhance': 'üß†',
                    'expand': 'üìù',
                    'generate': 'üéôÔ∏è',
                    'combine': '‚ú®'
                };
                const icon = stageIcons[preview.stage] || '‚úÖ';
                addActivity(icon, `${preview.stage_name} complete - awaiting review`, preview.stage);
            }

            hidePreviewPanel() {
                this.previewPanel.classList.add('hidden');
            }

            async continueWithSuggestion(suggestion) {
                if (!this.jobId) return;

                // Disable buttons while processing
                this.continueBtn.disabled = true;
                this.skipReviewsBtn.disabled = true;

                try {
                    const response = await fetch(`/api/job/${this.jobId}/continue`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ suggestion: suggestion || '' })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to continue');
                    }

                    // Log suggestion if provided
                    if (suggestion) {
                        addActivity('üí¨', `User guidance: "${suggestion.substring(0, 50)}${suggestion.length > 50 ? '...' : ''}"`, 'info');
                    }

                    // Hide preview and resume polling
                    this.hidePreviewPanel();
                    this.startPolling();

                } catch (error) {
                    showError('Failed to continue: ' + error.message);
                } finally {
                    this.continueBtn.disabled = false;
                    this.skipReviewsBtn.disabled = false;
                }
            }

            showComplete(data) {
                // Stop pipeline animation
                if (typeof stopPipeline === 'function') {
                    stopPipeline();
                }

                addActivity('‚úÖ', 'Audio generated successfully!', 'complete');

                this.hidePreviewPanel();
                progressSection.classList.add('hidden');
                resultSection.classList.remove('hidden');

                if (data.size_mb) {
                    resultSize.textContent = `Size: ${data.size_mb} MB`;
                }

                if (data.filename && resultFilename) {
                    resultFilename.textContent = data.filename;
                }

                if (data.download_id) {
                    downloadLink.href = `/download/${data.download_id}`;
                    if (data.filename) {
                        downloadLink.download = data.filename;
                    }
                    downloadLink.onclick = function() {
                        setTimeout(() => {
                            fetch(`/cleanup/${data.download_id}`, { method: 'POST' });
                        }, 300000);
                    };
                }

                if (data.transcript_id) {
                    transcriptLink.href = `/download-transcript/${data.transcript_id}`;
                    transcriptLink.classList.remove('hidden');
                    addActivity('üìÑ', 'Transcript available for download', 'complete');
                }

                this.isActive = false;
            }

            reset() {
                this.stopPolling();
                this.jobId = null;
                this.skipReviews = false;
                this.isActive = false;
                this.hidePreviewPanel();
                this.suggestionInput.value = '';
                document.querySelectorAll('.quick-btn').forEach(b => b.classList.remove('selected'));
            }

            extractDomain(url) {
                try {
                    const u = new URL(url);
                    return u.hostname.replace('www.', '');
                } catch {
                    return url.substring(0, 30);
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Initialize interactive pipeline
        const interactivePipeline = new InteractivePipeline();

        // Check if AI enhance is enabled to use interactive pipeline
        function shouldUseInteractivePipeline() {
            const aiEnhance = document.getElementById('ai_enhance');
            return aiEnhance && aiEnhance.checked;
        }

        // Override form submission to use interactive pipeline when AI enhance is on
        const originalFormHandler = form.onsubmit;
        form.addEventListener('submit', async function(e) {
            // Only intercept if AI enhance is enabled
            if (!shouldUseInteractivePipeline()) {
                return; // Let the original handler process it
            }

            e.preventDefault();
            e.stopPropagation();

            const text = document.getElementById('text').value;
            const file = fileInput.files[0];

            if (!text.trim() && !file) {
                alert('Please paste a script or upload a file.');
                return;
            }

            // Reset workbench state
            resetWorkbench();
            startTime = Date.now();

            // Show progress and start pipeline animation
            form.classList.add('hidden');
            progressSection.classList.remove('hidden');
            resultSection.classList.add('hidden');
            errorSection.classList.add('hidden');

            // Initialize and start pipeline visualization
            if (typeof initPipeline === 'function') {
                initPipeline();
                startPipeline('analyze');
            }

            // Use interactive pipeline
            const formData = new FormData(form);
            await interactivePipeline.startJob(formData);

        }, true); // Use capture phase to intercept before original handler
    </script>
</body>
</html>
